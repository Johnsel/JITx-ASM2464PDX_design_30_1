#use-added-syntax(jitx)
defpackage ASM001/components/USB/USBTypeC :
  import core
  import jitx
  import jitx/commands
  import jitx/parts

  import jsl

public pcb-component conn-component :
  description = "USB Type-C SMD Connectors ROHS"
  manufacturer = "Molex"
  mpn = "2012670005"
  datasheet = "https://www.molex.com/content/dam/molex/molex-dot-com/products/automated/en-us/salesdrawingpdf/201/201267/2012670005_sd.pdf"
  reference-prefix = "J"

  property(self.rated-temperature) = min-max(-40.0, 105.0)

  port TX : diff-pair[2]
  ; port TX[1] : diff-pair

  port RX : diff-pair[2]
  ; port RX[1] : diff-pair

  port D : diff-pair[2]
  ; port D[1] : diff-pair

  pin-properties :
    [pin:Ref | pads:Ref ... | side:Dir | bank:Ref | row:Int ]

    [VBUS[0] | A[4] | Right | A-side | 0]
    [VBUS[1] | A[9] | Right | A-side | 0]
    [VBUS[3] | B[4] | Right | B-side | 0]
    [VBUS[2] | B[9] | Right | B-side | 0]

    [D[0].P | A[6] | Left | A-side | 1]
    [D[0].N | A[7] | Left | A-side | 1]

    [TX[0].P | A[2] | Left | A-side | 1]
    [TX[0].N | A[3] | Left | A-side | 1]

    [RX[0].P | B[11] | Left | A-side | 1]
    [RX[0].N | B[10] | Left | A-side | 1]

    [CC[0] | A[5] | Left | A-side | 1]
    [SBU[0] | A[8] | Left | A-side | 1]

    [D[1].P | B[6] | Left | B-side | 1]
    [D[1].N | B[7] | Left | B-side | 1]

    [TX[1].P | B[2] | Left | B-side | 1]
    [TX[1].N | B[3] | Left | B-side | 1]

    [RX[1].P | A[11] | Left | B-side | 1]
    [RX[1].N | A[10] | Left | B-side | 1]

    [CC[1] | B[5] | Left | B-side | 1]
    [SBU[1] | B[8] | Left | B-side | 1]

    [GND[0] | A[1] | Left | A-side | 2]
    [GND[1] | A[12] | Left | A-side | 2]
    [GND[2] | B[12] | Left | B-side | 2]
    [GND[3] | B[1] | Left | B-side | 2]

    ; Shield
    [SHIELD | M[1] M[2] M[3] M[4] | Right | A-side | 2]

  val symbol-params = BoxSymbolParams(
    ; width = 1.0,
    ; height = 1.0,
    ; pin-length = 0.1,
    ; pin-width = 0.1,
    pin-pitch = 2.0
  )
  val box = BoxSymbol(self, params = symbol-params)
  set-grid(box, [3, 2], Ref("A-side"))
  set-grid(box, [3, 2], Ref("B-side"))

  set-alignment(N, self.VBUS)
  set-alignment(S, self.GND)
  set-alignment(S, self.SHIELD)

  set-head-margin(0.5, self.TX[0].P, self.TX[1].P)
  set-head-margin(0.5, self.RX[0].P, self.RX[1].P)
  set-head-margin(0.5, self.CC[0], self.CC[1])

  assign-symbols(
    Ref("A-side") => box,
    Ref("B-side") => box,
  )

  val pkg = USBTypeC-Pkg()
  assign-landpattern $ create-landpattern(pkg)

  diff-pin-model(self.D[0],   delay = typ(10.0e-15) loss = typ(0.1))
  diff-pin-model(self.D[1],   delay = typ(10.0e-15) loss = typ(0.1))

  diff-pin-model(self.TX[0],  delay = typ(10.0e-15) loss = typ(0.1))
  diff-pin-model(self.TX[1],  delay = typ(10.0e-15) loss = typ(0.1))

  diff-pin-model(self.RX[0],  delay = typ(10.0e-15) loss = typ(0.1))
  diff-pin-model(self.RX[1],  delay = typ(10.0e-15) loss = typ(0.1))

  reversible-dual-pair(self.D[0], self.D[1])


public pcb-module device :
  port conn : usb-c-connector

  public inst J : conn-component

  net (conn.vbus.V+ J.VBUS[0] J.VBUS[1] J.VBUS[2] J.VBUS[3])

  topo-net(J.SBU[0] => conn.bus.sbu[0])
  topo-net(J.SBU[1] => conn.bus.sbu[1])
  
  topo-net(J.CC[0] => conn.bus.cc[0])
  topo-net(J.CC[1] => conn.bus.cc[1])

  require usb-data : dual-pair from J
  topo-net(conn.bus.data, usb-data.A)
  topo-net(usb-data.A, usb-data.B)

  topo-net(J.TX[0], conn.bus.lane[0].TX)
  topo-net(J.RX[0], conn.bus.lane[0].RX)
  topo-net(J.TX[1], conn.bus.lane[1].TX)
  topo-net(J.RX[1], conn.bus.lane[1].RX)

  net (J.GND[0] J.GND[1] J.GND[2] J.GND[3] conn.vbus.V-)
  net (conn.shield J.SHIELD)

doc: \<DOC>
USB-C USB 2.0 High-Speed Interface

This is a basic USB2 480mbps capable USB-C interface.
It doesn't include the SuperSpeed connections, but does
provide the necessary features to support a simple debug
interface, like to an FTDI.

Circuit Includes:
1.  USB-C connector
2.  Pull-downs for CC1 and CC2
3.  ESD protection diodes for the USB2 data bus.
4.  Shield termination

@param R-query Resistor query parameters for customizing resistor selection - default is `get-default-resistor-query()`.
@param C-query Capacitor query parameters for customizing capacitor selection - default is `get-default-capacitor-query()`.

@member USB USB2 Differential Signaling Bus
@member VDD-USB USB Power Rail, typically 5V.

<DOC>
public defn USBC-HighSpeed-Iface (
  R-query:ResistorQuery = get-default-resistor-query(),
  C-query:CapacitorQuery = get-default-capacitor-query(),
  ):
  pcb-module USBC-HighSpeed-Iface:
    port USB : usb-data
    port VDD-USB : power

    public inst USBC : device

    net (VDD-USB, USBC.conn.vbus)
    net GND (VDD-USB.V-)

    ; Two separate pull down resistors per the USB-C
    ;  spec Section 4.5.1.2.1
    ; https://www.usb.org/sites/default/files/USB%20Type-C%20Spec%20R2.0%20-%20August%202019.pdf
    val pu-R = create-resistor(R-query, resistance = 5.1e3, precision = (1 %))
    for i in indices(USBC.conn.bus.cc) do:
      val n = to-string("CC%_-R" % [i])
      insert-pulldown(USBC.conn.bus.cc[i], GND, elem-type = pu-R, inst-name? = n, make-public = true)

    public inst esd-prot : diodes/ESD224DQAR/device
    net (esd-prot.GND[1], esd-prot.GND[2], GND)

    ; Construct the topology from the module port, through
    ;  the ESD protector, and then terminating in the connector device.
    require esd-pair:dual-pair from esd-prot
    topo-pair(USB.data => esd-pair.A => esd-pair.B => USBC.conn.bus.data)
    ; By setting the signal end - then the routing structure application
    ;   can apply to the entirety of the bus.
    set-signal-end(USB.data, USBC.conn.bus.data)

    ; Shield Termination
    inst shield-term : shield-termination(R-query, C-query)
    net (shield-term.SHIELD, USBC.conn.shield)
    net (shield-term.GND, GND)

  USBC-HighSpeed-Iface


doc: \<DOC>
USB-C USB 4 v1 Interface

This is a basic USB4 20 Gbit capable USB-C interface.

Circuit Includes:
1.  USB-C connector
2.  Pull-downs for CC1 and CC2
3.  ESD protection diodes for the USB2 data bus.
4.  ESD protection diodes for the USB4 lanes.
5.  Lane protection capacitors and bleed resistors.
6.  Shield termination

@param lanes Amount of high speed lanes - default is `2`
@param R-query Resistor query parameters for customizing resistor selection - default is `get-default-resistor-query()`.
@param C-query Capacitor query parameters for customizing capacitor selection - default is `get-default-capacitor-query()`.

@member USB USB-C Signaling Bus
@member VDD-USB USB Power Rail, typically 5V.

<DOC>
public defn USBC-USB4-Iface (
  lanes:Int = 2,
  R-query:ResistorQuery = get-default-resistor-query(),
  C-query:CapacitorQuery = get-default-capacitor-query(),
  ):
  pcb-module USBC-USB4-Iface:
    port USB : usb-c(2)
    port VDD-USB : power

    public inst USBC : device

    net (VDD-USB, USBC.conn.vbus)
    net GND (VDD-USB.V-)

    ; According to USB4 System Design Guidelines
    val bleed-R = create-resistor(R-query, 
                                case = valid-smd-pkgs("0201"), 
                                resistance = Interval(200.0e3, 242.0e3) ; 220k ohm
                                )
    
    val rx-ac-C = create-capacitor(C-query, 
                                  case = valid-smd-pkgs("0201"), 
                                  capacitance = Interval(300.0e-9, 363.0e3)) ; 0.33uf

    val tx-ac-C = create-capacitor(C-query,
                                  case = valid-smd-pkgs("0201"), 
                                  capacitance = Interval(135.0e-9, 265.0e3)) ; 0.22uf

    ; USB4 ESD Protection component definition
    val lane-esd-cap = create-part(mpn = "ESD132-B1-W0201 E6327", manufacturer = "Infineon")
  
    ; USB-C CC pull-down resistors
    val cc-R = create-capacitor(C-query, capacitance = 2.2E-9, precision = (10 %), rated-voltage = 50.0, case = valid-smd-pkgs("0201")) ; 220 pf / 50V
    for i in indices(USBC.conn.bus.cc) do:
      val n = to-string("CC%_-R" % [i])
      val cc_pd-R = insert-pulldown(USBC.conn.bus.cc[i], GND, elem-type = cc-R, inst-name? = n, make-public = true)
      topo-net(USBC.conn.bus.cc[i] => cc_pd-R.p[1])

    ; Each lane has ESD protection, bleed resistors, blocking caps
    inst shunt-TX : symmetric-shunt(bleed-R)[lanes]
    inst shunt-RX : symmetric-shunt(bleed-R)[lanes]

    inst tx-bcap : dp-coupler(tx-ac-C)[lanes]
    inst rx-bcap : dp-coupler(rx-ac-C)[lanes]

    inst lane-esd-tx : dp-coupler(lane-esd-cap, pre-pose = loc(0.0, 0.0, 90.0))[lanes]
    inst lane-esd-rx : dp-coupler(lane-esd-cap, pre-pose = loc(0.0, 0.0, 90.0))[lanes]


    for i in 0 to lanes do:
      ; side channel signals
      topo-net(USB.cc[i] => USBC.conn.bus.cc[i])
      topo-net(USB.sbu[i] => USBC.conn.bus.sbu[i])

      ; TX bleed resistors
      topo-pair(USBC.conn.bus.lane[i].TX => lane-esd-tx[i] => shunt-TX[i].A => shunt-TX[i].B => tx-bcap[i] =>  USB.lane[i].TX)
      net (shunt-TX[i].COMMON, GND)

      ; RX bleed resistors
      ; topo-pair(USBC.conn.bus.lane[i].RX => lane-esd-rx[i] => shunt-RX[i].A => shunt-RX[i].B => rx-bcap[i] => USB.lane[i].RX)
      ; topo-pair(USBC.conn.bus.lane[i].RX => lane-esd-rx[i] => shunt-RX[i].A => shunt-RX[i].B => rx-bcap[i] => USB.lane[i].RX)
      topo-pair(USBC.conn.bus.lane[i].RX => lane-esd-rx[i] => shunt-RX[i].A => shunt-RX[i].B => rx-bcap[i] => USB.lane[i].RX)
      net (shunt-RX[i].COMMON, GND)

      ; Set the signal end for the routing application
      ; set-signal-end(USB.lane[i].TX, USBC.conn.bus.lane[i].TX) 
      ; set-signal-end(USB.lane[i].RX, USBC.conn.bus.lane[i].RX)

    ; USB2 ESD Protection
    public inst esd-prot : diodes/ESD224DQAR/device
    net (esd-prot.GND[1], esd-prot.GND[2], GND)

    ; Construct the topology from the module port, through
    ;  the ESD protector, and then terminating in the connector device.
    require esd-pair:dual-pair from esd-prot
    topo-pair(USB.data => esd-pair.A => esd-pair.B => USBC.conn.bus.data)
    ; By setting the signal end - then the routing structure application
    ;   can apply to the entirety of the bus.
    set-signal-end(USB.data, USBC.conn.bus.data)

    ; Shield Termination
    inst shield-term : shield-termination(R-query, C-query)
    net (shield-term.SHIELD, USBC.conn.shield)
    net (shield-term.GND, GND)

  USBC-USB4-Iface




; public pcb-module circuit :
;   port GND
;   port VBUS
;   port SHIELD
;   port USB-C : usb-c(2)

;   public inst sw : ASM001/components/USB/USBTypeC/conn-component

;   for g in pins(sw.GND) do :
;     net (GND g)
  
;   for g in pins(sw.VBUS) do :
;     net (VBUS g)

;   net (sw.CC1 USB-C.cc[0])
;   net (sw.CC2 USB-C.cc[1])

;   net (sw.SBU1 USB-C.sbu[0])
;   net (sw.SBU2 USB-C.sbu[1])

;   net (sw.D0.P sw.D1.P USB-C.data.P)
;   net (sw.D0.N sw.D1.N USB-C.data.N)
;   net (sw.TX1.P USB-C.lane[0].TX.P)
;   net (sw.TX1.N USB-C.lane[0].TX.N)
;   net (sw.RX1.P USB-C.lane[0].RX.P)
;   net (sw.RX1.N USB-C.lane[0].RX.N)
;   net (sw.TX2.P USB-C.lane[1].TX.P)
;   net (sw.TX2.N USB-C.lane[1].TX.N)
;   net (sw.RX2.P USB-C.lane[1].RX.P)
;   net (sw.RX2.N USB-C.lane[1].RX.N)

;   net (sw.SHIELD SHIELD)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; LandPattern Generator
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

val TYPE-C-WIDTH = 9.39
val TYPE-C-LENGTH = 8.3

public defstruct USBTypeC-Pkg <: Package :
  num-leads:Int with:
    as-method => true
    default => 24
  package-body:PackageBody with:
    as-method => true
    default => PackageBody(
      width = TYPE-C-WIDTH +/- 0.15
      length = typ(TYPE-C-LENGTH),
      height = 3.71 +/- 0.15
    )
  density-level:DensityLevel with:
    as-method => true
    default => DENSITY-LEVEL
with:
  printer => true
  keyword-constructor => true

public defmethod name (pkg:USBTypeC-Pkg) -> String :
  "USB Type C Connector"

defn compute-offset () -> Pose :
  ; Compute the offset coordinate system which I'm defining
  ;   to be the upper right mounting hole for the recommended
  ;   landpattern as shown on page 2 of the datasheet
  val w2 = 8.64 / 2.0
  ;  The mounting hole is a bit off-center from the connector body
  ;  Here I adjust for that. We need to mark the board edge as
  ;  slighty offset from the package body.
  val temp = TYPE-C-LENGTH - (7.13 + 0.18)
  val h2 = (TYPE-C-LENGTH / 2.0) - temp
  loc(w2, h2)

public defmethod build-all (
  pkg:USBTypeC-Pkg,
  root:VirtualLP
  ) -> False :
  ; Create a child node with its center shift from the center of mass of the
  ;  connector's 3D body to the location specified as the quasi-origin of the
  ;  mechanical drawing of the datasheet on page 4.
  ;  This origin is centered in the left mechanical mounting hole
  val origin = create-child(root, offset = compute-offset(), name = "origin" )
  package-build-all-order(pkg, root)

public defmethod build-silkscreen (
  pkg:USBTypeC-Pkg
  root:VirtualLP
  ) -> False:
  create-silkscreen-outline(root, package-body(pkg), density-level = density-level(pkg))
  build-smd-pin-1-dot(root, dir = Up, pin-1-id = #R(A[1]))
  add-reference-designator(root)

public defmethod courtyard-excess (
  pkg:USBTypeC-Pkg
) -> Double :
  0.25

public defmethod build-pads (
  pkg:USBTypeC-Pkg,
  root:VirtualLP
  ) :

  val vp = get-child!(root, "origin")

  ; I'm considering the footprint as being made of 3 sets of
  ;   of pads that compose into one land pattern.
  ; 1. The staggered grid of pins for the communications interface, ie A1-12, B2-11
  ; 2. The Ground pads B1 and B12 which are shaped and placed differently than the
  ;     staggered grid
  ; 3. The through-hole mounting slots.

  build-staggered-grid(pkg, vp)
  build-ground-pads(pkg, vp)
  build-mounting-holes(pkg, vp)


public defstruct USBCGridNumbering <: Numbering:
  num-cols:Int

public defmethod to-pad-id (x:USBCGridNumbering, row:Int, column:Int ) -> Int|Ref :
  ; Staggered grids use 2x the number of columns
  ;   so we convert to the standard grid for the
  ;   ref to correct.
  var index = column / 2
  val ret = if row == 0 :
    ;  Incrementing
    ;  There is a skip in the middle of the row.
    if index > 5:
      index = index - 1
    #R(A)[index + 1]
  else:
    ; Decrementing
    val d-index = num-cols(x) - index - 1
    #R(B)[d-index]

  ret

defn build-staggered-grid (
  pkg:USBTypeC-Pkg,
  vp:VirtualLP
  ):

  val pad-H = 0.7
  val pad-W = 0.3
  val pad-pitch = 0.5
  val x-span = 6.0
  val x-off = x-span + ((8.64 - x-span) / 2.0)
  val origin = create-child(vp, offset = loc((- x-off), 0.46 - (1.0 / 2.0)))

  val num-cols = 13
  val pad-seq = to-tuple $ pad-grid-smt(
    pad-size = Dims(pad-W, pad-H)
    planner = StaggerPadPlanner(shaper = rect-shaper, omits = [[0, 12], [1, 1], [1, 23], [1, 25]]),
    lead-grid = GridPlanner(
      ; Stagger Planner Creates 2x the number of columns
      ;   as pads - hence the pitch is half the actual
      ;   physical pitch between pins.
      pitch = Dims(pad-pitch / 2.0, 1.0 + pad-H)
      columns = 2 * num-cols
      rows = 2,
      anchor = W
    )
    ; Skip every other other column because of the stagger
    ;  grid.
    num-scheme = USBCGridNumbering(num-cols)
    )

  append-all(origin, pad-seq)


defn build-ground-pads (
  pkg:USBTypeC-Pkg,
  vp:VirtualLP
  ):
  val pad-H = 0.7
  val pad-W = 0.3
  val x-off = (8.64 - 6.1) / 2.0
  val y-off = 0.46 - (1.0 + (pad-H / 2.0))
  val origin = create-child(vp, offset = loc((- x-off), y-off) )

  val padDef = smd-pad(0.9, pad-H)
  val B1 = VirtualPad(#R(B[1]), padDef, loc(0.0, 0.0))
  append(origin, B1)
  val B12 = VirtualPad(#R(B[12]), padDef, loc((- 6.10), 0.0))
  append(origin, B12)

defn build-mounting-holes (
  pkg:USBTypeC-Pkg,
  vp:VirtualLP
  ):

  val M12-L = 8.64
  val M34-L = 9.24

  val M12-L2 = M12-L / 2.0
  val M34-L2 = M34-L / 2.0

  val origin = create-child(vp, offset = loc((- M12-L2), 0.0))

  val h1 = Capsule(0.6, 1.6)
  val cu1 = Capsule(1.1, 2.1)
  val M12-def = pth-pad(h1, cu1)

  val M1 = VirtualPad(#R(M[1]), M12-def, loc((- M12-L2), 0.0))
  val M2 = VirtualPad(#R(M[2]), M12-def, loc(M12-L2, 0.0))


  val h2 = Capsule(0.6, 2.1)
  val cu2 = Capsule(1.1, 3.6)

  defn compute-cu-offset (h:Capsule, cu:Capsule):
    ; Capsule for the copper pad and the hole are
    ;  constrained such that the center marks for
    ;  the hole and copper pad are co-centered on
    ;  one side

    val rh = width(h)
    val rc = width(cu)

    val H-l = (height(h) - (rh)) / 2.0
    val C-l = (height(cu) - (rc)) / 2.0
    C-l - H-l

  val y-off = compute-cu-offset(h2, cu2)
  val shifted-cu = loc(0.0, y-off) * cu2
  val M34-def = pth-pad(h2, shifted-cu)

  val M34-y-off = -5.36
  val M3 = VirtualPad(#R(M[3]), M34-def, loc((- M34-L2), M34-y-off))
  val M4 = VirtualPad(#R(M[4]), M34-def, loc(M34-L2, M34-y-off))

  append-all(origin, [M1, M2, M3, M4])
