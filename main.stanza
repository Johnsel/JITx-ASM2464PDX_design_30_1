; Generated by JITX 3.25.0
#use-added-syntax(jitx)
defpackage ASM001/main :
  import core
  import collections
  import jitx
  import jitx/commands
  import jitx/parts

  import jsl
  import jsl/bundles
  import jsl/protocols/usb
  import jsl/si/constraints
  import jsl/si/pairs
  import jsl/si/helpers
  import jsl/si/couplers
  import jsl/symbols/net-symbols

  import utils/time
  import ocdb/utils/checks
  import ocdb/utils/generic-components
  import ocdb/utils/generator-utils

  import ASM001/helpers
  import ASM001/components/common
  import ASM001/module/power

  import debug/test-points

; Define the shape/size of the board
val board-shape = RoundedRectangle(100.0, 100.0, 2.0)

; Module to run as a design
pcb-module ASM001-design :
  ; draw a version number and date on the board silkscreen
  val mydate:String = get-time-string("%Y-%m-%d")
  inst version-label  : ocdb/artwork/board-text/version-silkscreen(to-string("ASM2464PDX 4x M.2 board | Version 0.2 %_" % [get-time-string("%Y-%m-%d")])) ; make a version label text on silkscreen
  place(version-label) at loc(0.0, height(board-shape) / 2.0 - 5.0) on Bottom ; place the version label text at specified location

  ; setup logo
  inst logo : ocdb/artwork/jitx-logo/logo(10.0)
  place(logo) at loc(10.0, -5.0, 0.0) on Bottom
   
  val R-query = get-default-resistor-query()
  val C-query = get-default-capacitor-query()

  inst power-management : ASM001/module/power/power-management
  inst asm2464pdx : ASM001/components/Asmedia/ASM2464PDX/module
  inst usb4_type_c : ASM001/components/USB/USBTypeC/USBC-USB4-Iface()
  inst W25Q32JVSSIQ : ASM001/components/Winbond/W25Q32JVSSIQ/module

  net (usb4_type_c.VDD-USB  power-management.VDD-USB)

  place(power-management) at loc(-30.0, 35.0) on Top
  place(asm2464pdx.sw) at loc(0.0, 0.0, 0.0) on Top
  place(usb4_type_c.USBC.J) at loc(-45.0, 15.0, 270.0) on Top
  place(W25Q32JVSSIQ.sw) at loc(1.5, 10.0, 270.0) on Top

  ; main power circuits
  net VBUS (power-management.VDD-USB.V+ asm2464pdx.vbus)
  net VCCH (power-management.VDD-3v3.V+ asm2464pdx.vcch); asm2464pdx.VCCA33)
  net VCCL (power-management.VDD-1v9.V+ asm2464pdx.vccl)
  net VDD (power-management.VDD-1v13.V+ asm2464pdx.vdd)
  net GND (power-management.VDD-USB.V- power-management.VDD-3v3.V- power-management.VDD-1v9.V- power-management.VDD-1v13.V- asm2464pdx.gnd)

  ; TODO: add a RC filter instead of a direct connection
  inst vcca33-jumper : jumper()
  net VCCH_VCCA33 (VCCH vcca33-jumper.p[1]) ; internally hook up both 3.3v busses
  net VCCA33 (vcca33-jumper.p[2] asm2464pdx.vcca33) ; internally hook up both 3.3v busses

  geom(GND) :
    copper-pour(LayerIndex(1, Top), isolate = 0.127, rank = 1) =  board-shape
    copper-pour(LayerIndex(3, Top), isolate = 0.127, rank = 1) =  board-shape
    copper-pour(LayerIndex(4, Top), isolate = 0.127, rank = 1) =  board-shape
  
  ; topo-net(usb4_conn.vbus.V- => GND => power-management.VDD-USB.V-)
  ; topo-net(usb4_type_c.USB, usb4_data)



  net (VCCH W25Q32JVSSIQ.VDD)
  net (GND W25Q32JVSSIQ.GND)

  ;;;;; generic component types
  val r_4k7 = create-resistor(R-query, 
                              case = ["0201", "0402"], 
                              resistance = 4.7e3) ; 4.7K ohm
  val r_100K = create-resistor(R-query, 
                              case = ["0201", "0402"], 
                              resistance = 100.0e3) ; 100K ohm

  val r_12k1 = create-resistor(R-query, 
                              case = ["0201", "0402"], 
                              resistance = 12.1e3,
                              tolerance = 0.01) ; 12.1K ohm

  val c_1uF50V = create-capacitor(C-query, 
                                case = ["0201", "0402"], 
                                capacitance = 1.0e-6,
                                rated-voltage = 50.0) ; 1uF, 50V

  ; ASM2464PDX config straps
  insert-pullup(asm2464pdx.sw.UART_TX, asm2464pdx.vcch,
                    elem-type = r_4k7,
                    inst-name? = to-string("uart_tx-R"),
                    make-public = true)

  ; RST# RC pull-up
  insert-pullup(asm2464pdx.rst#, asm2464pdx.vcch,
                    elem-type = r_100K,
                    inst-name? = to-string("r_100K"),
                    make-public = true)

  insert-pulldown(asm2464pdx.rst#, GND,
                    elem-type = c_1uF50V,
                    inst-name? = to-string("c_1uF50V"),
                    make-public = true)
  
  ; Precision R for UREXT
  insert-pulldown(asm2464pdx.urext, GND,
                    elem-type = r_12k1,
                    inst-name? = to-string("UREXT-R"),
                    make-public = true)
  
  ; TEST_EN pull-down
  insert-pulldown(asm2464pdx.test_en, GND,
                    elem-type = r_4k7,
                    inst-name? = to-string("TEST_EN-R"),
                    make-public = true)

  ;; ASM2464PDX SPI memory
  net (asm2464pdx.spi W25Q32JVSSIQ.spi)
  insert-pullup(W25Q32JVSSIQ.sw.SPI_IO2, asm2464pdx.vcch,
                  elem-type = r_4k7,
                  inst-name? = to-string("spi_wp#-R"),
                  make-public = true)

  insert-pullup(W25Q32JVSSIQ.sw.SPI_IO3, asm2464pdx.vcch,
                  elem-type = r_4k7,
                  inst-name? = to-string("spi_hold#-R"),
                  make-public = true)   

  ;; ASM2464PDX 25Mhz 18Pf crystal
  inst crystal_25mhz: ASM001/components/ABRACON/ABMM2-25_000MHZ-D1-T/component
  inst crystal_c : ASM001/components/KYOCERA-AVX/_04025A100FAT2A/component
  
  net (crystal_25mhz.GND0 GND)
  net (crystal_25mhz.GND1 GND)

  net (asm2464pdx.xi crystal_25mhz.p[1] crystal_c.p[1])
  net (asm2464pdx.xo crystal_25mhz.p[3] crystal_c.p[2])

  ; USB4 Type-C connector
  val usb4-lanes = 2
  require asm2464pdx_usb-c : usb-c(usb4-lanes) from asm2464pdx

  net (usb4_type_c.VDD-USB.V+ asm2464pdx.vbus)
  net (usb4_type_c.VDD-USB.V- asm2464pdx.gnd)

  net cc0 (usb4_type_c.USB.cc[0], asm2464pdx_usb-c.cc[0])
  net cc1 (usb4_type_c.USB.cc[1], asm2464pdx_usb-c.cc[1])

  net sbu0 (usb4_type_c.USB.sbu[0], asm2464pdx_usb-c.sbu[0])
  net sbu1 (usb4_type_c.USB.sbu[1], asm2464pdx_usb-c.sbu[1])

  val usb-version = USB4
  val usb-trace-imped = to-int(typ(usb-get-trace-impedance(usb-version)))
  val usb-route-struct = diff-routing-struct(substrate, 100);, neckdown = DifferentialNeckDown(clearance = 0.05))
  val usb-cst = USB-Constraint(proto = usb-version, route-struct = usb-route-struct)


  for i in 0 to usb4-lanes  do:
    topo-pair(usb4_type_c.USB.lane[i].TX => asm2464pdx_usb-c.lane[i].TX) 
    set-signal-end(usb4_type_c.USB.lane[i].TX, asm2464pdx_usb-c.lane[i].TX)
    ; constrain-topology(usb4_type_c.USB.lane[i].TX, asm2464pdx_usb-c.lane[i].TX, usb-cst)

    topo-pair(usb4_type_c.USB.lane[i].RX => asm2464pdx_usb-c.lane[i].RX) 
    set-signal-end(usb4_type_c.USB.lane[i].RX, asm2464pdx_usb-c.lane[i].RX)
    ; constrain-topology(usb4_type_c.USB.lane[i].RX, asm2464pdx_usb-c.lane[i].RX, usb-cst)

    topo-net(asm2464pdx_usb-c.cc[i] => usb4_type_c.USB.cc[i]) 
    topo-net(asm2464pdx_usb-c.sbu[i] => usb4_type_c.USB.sbu[i]) 
      
  ; inst header : header(2,1)

  ; make-test-points(usb4_type_c.sw.VBUS[0])
    
  ; ; Add Keepout for the USB interface.
  ; val pt-pd-map = port-to-pads(usb4_type_c.sw)
  ; val pds = for kvp in pt-pd-map seq-cat:
  ;   value(kvp)
  ; val b = bounds(pds, layer-spec = SolderMask(Top), expand-by = 0.25)
  ; val KO = KeepoutOverlay(to-Rectangle(b))
  ; val USB-KO-layers =
  ; make-keepout-overlay(
  ;   KO, usb4_type_c.sw,
  ;   ; I'm creating a keepout for all layers except the ground
  ;   ;  plane on `Top + 1` and Top + 2 so I can still route some power planes underneat.
  ;   layer-set = conductors-by-index(stackup(substrate), omits = [
  ;     Top + 1
  ;     Top + 2
  ;     ])
  ;   name = "USBC-Keepout"
  ;   )

  ; PCIe 4x M.2
  val version = PCIE-V4
  val trace-imped = to-int(typ(pcie-get-trace-impedance(version)))
  val imped-value = diff-routing-struct(substrate, trace-imped);, neckdown = DifferentialNeckDown(clearance = 0.1))
  val cst = PCIe-Constraint(version, imped-value)

  val pcie-b-cap = block-cap(220.0e-9)

  ; Construct a typical connector setup
  ;  for a 4x 1 lane configuration. This means a
  ;  straight through `tx => bcap => tx` and `rx;;[po;] => rx`
  ;  configuration.
  val num_m2 = 1
  inst m2_connector : ASM001/components/TE_1-2199230-6/module;[num_m2]

  for i in 0 to num_m2 do:
    ; val src-ep = asm2464pdx.pcie-1x[i]
    require src-ep : pcie-std(4) from asm2464pdx
    ; require src-ep : pcie-std(1) from asm2464pdx
    require dst-ep : pcie-std(4) from m2_connector;[i]

    within [src, dst] = constrain-topology(src-ep, dst-ep, cst):
      ; Here we construct the circuit topology for the link
      ;   Note that we don't need to worry about any of the constraint
      ;   application, as that is handled by the `PCIe-Constraint` type.
      ;   You can add other components in the topology as you wish - below
      ;   is a typical basic implementation.
      for i in indices(src.data.lane) do:
        inst tx-coupler : dp-coupler(pcie-b-cap)
        topo-pair(src.data.lane[i].TX => tx-coupler => dst.data.lane[i].TX)
        ; ; No Blocking Caps on the Receive side.
        topo-pair(src.data.lane[i].RX => dst.data.lane[i].RX)

      topo-pair(src.data.refclk => dst.data.refclk)
      ; The control signals do not demand a topology so
      ;  we just use a straight net connection.
      net (src.control, dst.control)
      ; net (GND m2_connector[i].gnd)


  val y-loc = [-36.0 - (to-double(0) * -24.0),(-36.0 - (to-double(1) * -24.0)),(-36.0 - (to-double(2) * -24.0)),(-36.0 - (to-double(3) * -24.0))]

  place(m2_connector.sw) at loc(35.0, y-loc[0], 90.0) on Bottom      
  ; place(m2_connector[0].sw) at loc(35.0, y-loc[0], 90.0) on Bottom      
  ; place(m2_connector[1].sw) at loc(35.0, y-loc[1], 90.0) on Bottom      
  ; place(m2_connector[2].sw) at loc(35.0, y-loc[2], 90.0) on Bottom      
  ; place(m2_connector[3].sw) at loc(35.0, y-loc[3], 90.0) on Bottom      

  ; schematic symbols
  symbol(GND) = GND-SYMB
  symbol(VBUS) = PWR-SYMB
  symbol(VCCH) = PWR-SYMB
  symbol(VCCL) = PWR-SYMB
  symbol(VDD) = PWR-SYMB

; Set the :
;     design-name     - a directory with this name will be created in the "designs" directory
;     board           - a Board object representing the stackup, rules and board shape for a particular design
;     signal-shrink   - a distance in mm to pull back copper signals from the board edge
setup-design("ASM001-design", board-shape, signal-shrink = 0.5)

; Set the top level module (the module to be compile into a schematic and PCB)
set-main-module(ASM001-design)

; View the results
; take a look at the BOM that was generated
; view-bom(BOM-STD)
; examine the schematic that was auto-generated
view-schematic()
; view the board that was created
view-board()

view-design-explorer()
; export-design()

